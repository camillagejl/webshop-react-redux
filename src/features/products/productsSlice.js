import {createAsyncThunk, createSlice} from '@reduxjs/toolkit';
import {fetchProducts} from "./productsAPI";

const initialState = {
    // Initial state of the products is an empty array, which will be populated by our API call.
    products: [],
    productsStatus: 'idle',

    // The cart is empty, and will be populated by the products we add to it.
    cart: {
        products: {}
    }
};

// Redux itself handles all actions synchronously. The Thunk middleware makes
// it possible to use async functions, that will run before the next actions.
// Redux Toolkit provides this createAsyncThunk which makes the structure more simple.
export const fetchProductsAsync = createAsyncThunk(
    'fetchProducts',
    async () => {
        const response = await fetchProducts();
        return response.data;
    }
);

// createSlice is where we define our reducers, and which state it should use to create new states.
// Reducers take the state and run a given action, creating a new version of the state.

// In Redux, it is possible, but bad practice, to mutate the state. Mutating the state undermines a big
// point of using Redux. However, Redux Toolkit makes it possible to use "mutating" logic with Immer
// library, so the reducers don't mutate the state but create a new one.
export const productsSlice = createSlice({
    name: 'products',
    initialState,
    reducers: {
        productIncrement: (state, action) => {
            const dest = state.cart.products;
            const product = action.payload.product;

            if (!dest[product]) dest[product] = 0;
            dest[product]++;
        },
        productDecrement: (state, action) => {
            const dest = state.cart.products;
            const product = action.payload.product;

            if (dest[product]) {
                if (dest[product] === 1) delete dest[product];
                if (dest[product] > 0) dest[product]--;
            }
        },
        productAmountByValue: (state, action) => {
            const dest = state.cart.products;
            const product = action.payload.product;
            const amount = action.payload.amount;

            if (amount > 0) dest[product] = amount;
            if (amount <= 0) delete dest[product];
        }
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder

            // When the function is first called and pending, it changes the productsStatus to loading.
            .addCase(fetchProductsAsync.pending, (state) => {
                state.productsStatus = 'loading';
            })

            // If the data is fetched successfully:
            .addCase(fetchProductsAsync.fulfilled, (state, action) => {
                state.products = action.payload;
                state.productsStatus = 'loaded';
            })

            // If an error occurs:
            .addCase(fetchProductsAsync.rejected, (state, action) => {
                state.productsStatus = 'failed';
            });
    },
});

// Exports the reducers that we need in other files.
export const {productIncrement, productDecrement, productAmountByValue} = productsSlice.actions;

// To select specified values or parts of the state, se use 'useSelector()'.
// useSelector needs the to know which part of the the state we want to select, and instead of defining it inline
// every time we want to use the state, we can use the variables saved below.
export const selectProducts = (state) => state.products.products;
export const selectProductsStatus = (state) => state.products.productsStatus;
export const selectCart = (state) => state.products.cart.products;

// The below selectors don't just return part of the state the same way as the above, but gives us computed properties
// based on the state. I.e. the selectCartProducts returns all the products in the cart, with the information taken from
// the products array in state.
export const selectCartProducts = (state) => {
    const products = [];

    // Loops over all products in the cart
    for (const [cartProduct, amount] of Object.entries(state.products.cart.products)) {

        // Loops over all products in store to find the the product information for the products in cart.
        state.products.products.forEach(product => {
            if (product.name === cartProduct) {

                // If a product is in the cart, the information about the product is added to the array.
                products.push(product);
            }
        })
    }

    return products;
}

export const selectTotalsInCart = (state) => {
    let totalPrice = 0;
    let productsAmount = 0;

    for (const [cartProduct, amount] of Object.entries(state.products.cart.products)) {

        // Loops over all products to find the the product information.
        state.products.products.forEach(product => {
            if (product.name === cartProduct) {

                // Calculates the accumulated price for this product, and adds this to the total price.
                totalPrice += product.price * amount;

                // Adds the amount of this product to the total productsAmount.
                productsAmount += amount;
            }
        })
    }

    return {
        price: (Math.round((totalPrice) * 100) / 100).toFixed(2),
        amount: productsAmount
    }
}

export default productsSlice.reducer;