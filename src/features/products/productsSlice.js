import {createAsyncThunk, createSlice} from '@reduxjs/toolkit';
import {fetchProducts} from "./productsAPI";

const initialState = {
    // Initial state of the products is an empty array, which will be populated by our API call.
    products: [],
    productsStatus: 'idle',

    // The cart is empty, and will be populated by the products we add to it.
    cart: {
        products: {}
    }
};

// Redux itself handles all actions synchronously. The Thunk middleware makes it possible to use async functions,
// that will run before the next actions.
// Redux Toolkit provides this createAsyncThunk which makes the structure more simple.
export const fetchProductsAsync = createAsyncThunk(
    'fetchProducts',
    async () => {
        const response = await fetchProducts();
        return response.data;
    }
);

// createSlice is where we define our reducers, and which state it should use to create new states.
// Reducers take the state and run a given action, creating a new version of the state.

// In Redux, it is possible, but bad practice, to mutate the state. Mutating the state undermines the
// point of using Redux. However, Redux Toolkit makes it possible to use "mutating" logic with Immer
// library, so the reducers don't mutate the state but create a new one.
export const productsSlice = createSlice({
    name: 'products',
    initialState,
    reducers: {
        productIncrement: (state, action) => {
            const dest = state.cart.products;
            const product = action.payload.product;

            if (!dest[product]) dest[product] = 0;
            dest[product]++;
        },
        productDecrement: (state, action) => {
            const dest = state.cart.products;
            const product = action.payload.product;

            if (!dest[product]) dest[product] = 0;
            if (dest[product] === 1) delete dest[product];
            if (dest[product] > 0) dest[product]--;
        },
        productAmountByValue: (state, action) => {
            const dest = state.cart.products;
            const product = action.payload.product;
            const amount = action.payload.amount;

            if (amount > 0) dest[product] = amount;
            if (amount <= 0) delete dest[product];
        }
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(fetchProductsAsync.pending, (state) => {
                state.productsStatus = 'loading';
            })
            .addCase(fetchProductsAsync.fulfilled, (state, action) => {
                state.products = action.payload;
                state.productsStatus = 'idle';
                console.log(action.payload);
            })
            .addCase(fetchProductsAsync.rejected, (state, action) => {
                state.productsStatus = 'failed';
            });
    },
});

// Exports the reducers that we need in other files.
export const {productIncrement, productDecrement, productAmountByValue} = productsSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

// To select specified values or parts of the state, se use 'useSelector()'.
// useSelector needs the to know which part of the the state we want to select, and instead of defining it inline
// every time we want to use the state, we can use the variables saved below.
export const selectProducts = (state) => state.products.products;
export const selectProductsStatus = (state) => state.products.productsStatus;
export const selectCart = (state) => state.products.cart.products;

export default productsSlice.reducer;
